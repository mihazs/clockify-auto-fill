import PDFDocument from 'pdfkit';
import * as fs from 'fs-extra';
import * as path from 'path';
import dayjs from 'dayjs';
import { ClockifyTimeEntry } from './clockify';
import { Config } from '../commands/config';

export interface ReportData {
  month: string;
  year: number;
  entries: ClockifyTimeEntry[];
  totalHours: number;
}

export class PDFService {
  private reportDir: string;

  constructor(config: Config) {
    if (!config.reportDir) {
      throw new Error('Report directory not configured. Please set reportDir.');
    }
    this.reportDir = config.reportDir;
  }

  async generateMonthlyReport(reportData: ReportData): Promise<string> {
    await fs.ensureDir(this.reportDir);
    
    const fileName = `clockify-report-${reportData.year}-${reportData.month.padStart(2, '0')}.pdf`;
    const filePath = path.join(this.reportDir, fileName);

    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const stream = fs.createWriteStream(filePath);
      
      doc.pipe(stream);

      this.addHeader(doc, reportData);
      this.addSummary(doc, reportData);
      this.addTimeEntriesTable(doc, reportData.entries);
      this.addFooter(doc);

      doc.end();

      stream.on('finish', () => resolve(filePath));
      stream.on('error', reject);
    });
  }

  private addHeader(doc: InstanceType<typeof PDFDocument>, reportData: ReportData): void {
    const monthName = dayjs().month(parseInt(reportData.month) - 1).format('MMMM');
    
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .text('Clockify Time Report', 50, 50);
    
    doc.fontSize(14)
       .font('Helvetica')
       .text(`${monthName} ${reportData.year}`, 50, 80);
    
    doc.fontSize(10)
       .text(`Generated on: ${dayjs().format('YYYY-MM-DD HH:mm:ss')}`, 50, 100);

    doc.moveDown(2);
  }

  private addSummary(doc: InstanceType<typeof PDFDocument>, reportData: ReportData): void {
    const y = doc.y;
    
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Summary', 50, y);

    doc.fontSize(12)
       .font('Helvetica')
       .text(`Total Entries: ${reportData.entries.length}`, 50, y + 25)
       .text(`Total Hours: ${reportData.totalHours.toFixed(2)}`, 50, y + 45)
       .text(`Average Hours/Day: ${(reportData.totalHours / reportData.entries.length || 0).toFixed(2)}`, 50, y + 65);

    doc.moveDown(2);
  }

  private addTimeEntriesTable(doc: InstanceType<typeof PDFDocument>, entries: ClockifyTimeEntry[]): void {
    const tableTop = doc.y + 20;
    const itemHeight = 20;
    const pageHeight = 700;
    
    doc.fontSize(14)
       .font('Helvetica-Bold')
       .text('Time Entries', 50, doc.y);

    this.addTableHeaders(doc, tableTop);
    
    let currentY = tableTop + 30;
    
    entries.forEach((entry, index) => {
      if (currentY > pageHeight) {
        doc.addPage();
        currentY = 50;
        this.addTableHeaders(doc, currentY);
        currentY += 30;
      }
      
      this.addTableRow(doc, entry, currentY, index % 2 === 0);
      currentY += itemHeight;
    });
  }

  private addTableHeaders(doc: InstanceType<typeof PDFDocument>, y: number): void {
    doc.fontSize(10)
       .font('Helvetica-Bold');
    
    // Table headers
    doc.text('Date', 50, y + 10);
    doc.text('Project', 120, y + 10);
    doc.text('Description', 200, y + 10);
    doc.text('Start', 400, y + 10);
    doc.text('End', 450, y + 10);
    doc.text('Duration', 500, y + 10);
    
    // Header underline
    doc.moveTo(50, y + 25)
       .lineTo(550, y + 25)
       .stroke();
  }

  private addTableRow(doc: InstanceType<typeof PDFDocument>, entry: ClockifyTimeEntry, y: number, isEven: boolean): void {
    if (isEven) {
      doc.rect(50, y, 500, 18)
         .fill('#f9f9f9')
         .fill('#000000');
    }
    
    const startDate = dayjs(entry.timeInterval.start);
    const endTime = dayjs(entry.timeInterval.end);
    const duration = this.formatDuration(entry.timeInterval.duration);
    
    doc.fontSize(9)
       .font('Helvetica');
    
    doc.text(startDate.format('MM/DD'), 50, y + 5);
    doc.text(entry.project.name.substring(0, 12), 120, y + 5);
    doc.text(entry.description.substring(0, 30) + (entry.description.length > 30 ? '...' : ''), 200, y + 5);
    doc.text(startDate.format('HH:mm'), 400, y + 5);
    doc.text(endTime.format('HH:mm'), 450, y + 5);
    doc.text(duration, 500, y + 5);
  }

  private addFooter(doc: InstanceType<typeof PDFDocument>): void {
    doc.fontSize(8)
       .font('Helvetica')
       .text('Generated by Clockify Auto CLI', 50, 750, { align: 'center' });
  }

  private formatDuration(duration: string): string {
    // Handle case where duration might not be a string
    if (!duration || typeof duration !== 'string') {
      console.warn('Invalid duration format in formatDuration:', duration);
      return '0:00';
    }
    
    // Duration is in ISO 8601 format (PT8H30M)
    const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
    if (!match) return duration;
    
    const hours = match[1] ? parseInt(match[1].replace('H', '')) : 0;
    const minutes = match[2] ? parseInt(match[2].replace('M', '')) : 0;
    
    return `${hours}:${minutes.toString().padStart(2, '0')}`;
  }

  calculateTotalHours(entries: ClockifyTimeEntry[]): number {
    return entries.reduce((total, entry) => {
      const duration = entry.timeInterval.duration;
      
      // Handle case where duration might not be a string
      if (!duration || typeof duration !== 'string') {
        console.warn('Invalid duration format:', duration);
        return total;
      }
      
      const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
      
      if (match) {
        const hours = match[1] ? parseInt(match[1].replace('H', '')) : 0;
        const minutes = match[2] ? parseInt(match[2].replace('M', '')) : 0;
        return total + hours + (minutes / 60);
      }
      
      return total;
    }, 0);
  }
}